if ("undefined" != typeof responsiveVoice) console.log("ResponsiveVoice already loaded"), console.log(responsiveVoice);
    else var ResponsiveVoice = function () {
        var a = this;
        a.version = "1.8.1";
        console.log("ResponsiveVoice r" + a.version);
        a.responsivevoices = [
            {name: "Brazilian Portuguese Female", flag: "br", gender: "f", voiceIDs: [245, 124, 123, 125, 186, 223, 126]},
        {
            name: "Portuguese Female",
            flag: "br",
            gender: "f",
            voiceIDs: [128, 127, 129, 187, 224, 130]
        },
        a.voicecollection = [
            {
                name: "Raquel Compact"
            }, {
                name: "Luciana"
            }, {
                name: "pt-BR",
                rate: .25
            }, {
                name: "Fallback Brazilian Portugese",
                lang: "pt-BR",
                fallbackvoice: !0,
                service: "g2"
            }, {
                name: "Joana Compact"
            }, {
                name: "Joana"
            }, {
                name: "pt-PT",
                rate: .25
            }, {
                name: "Fallback Portuguese",
                lang: "pt-PT",
                fallbackvoice: !0
            }, {
                name: "Portuguese Brazil",
                lang: "pt_BR"
            }, {
                name: "Portuguese Portugal",
                lang: "pt_PT"
            }, {
                name: "Luciana",
                lang: "pt-BR"
            }, {
                name: "Joana",
                lang: "pt-PT"
            }, 
        ],
        a.is_chrome = -1 < navigator.userAgent.indexOf("Chrome"),
        
        a.systemvoices = null,
        a.CHARACTER_LIMIT = 100,
        a.VOICESUPPORT_ATTEMPTLIMIT = 1000,
        a.voicesupport_attempts = 0,
        a.fallbackMode = !1,
        a.WORDS_PER_MINUTE = 130,
        a.fallback_parts = null,
        a.fallback_part_index = 0,
        a.fallback_audio = null,
        a.fallback_playbackrate = 1,
        a.def_fallback_playbackrate = a.fallback_playbackrate,
        a.fallback_audiopool = [],
        a.msgparameters = null,
        a.timeoutId = null,
        a.OnLoad_callbacks = [],
        a.useTimer = !1,
        a.utterances = [],
        a.tstCompiled = function (a) {
            return eval("typeof xy === 'undefined'")
        },
        a.fallbackServicePath = "https://code.responsivevoice.org/" + (a.tstCompiled() ? "" : "develop/") + "getvoice.php",
        a.default_rv = a.responsivevoices[0],
        a.init = function () {
            a.is_android && (a.useTimer = !0);
            a.is_opera || "undefined" === typeof speechSynthesis ? (console.log("RV: Voice synthesis not supported"), a.enableFallbackMode()) : setTimeout(function () {
                var b = setInterval(function () {
                    var c = window.speechSynthesis.getVoices();
                    0 != c.length || null != a.systemvoices && 0 != a.systemvoices.length ? (console.log("RV: Voice support ready"), a.systemVoicesReady(c),clearInterval(b)) : (console.log("Voice support NOT ready"), a.voicesupport_attempts++, a.voicesupport_attempts > a.VOICESUPPORT_ATTEMPTLIMIT && (clearInterval(b), null != window.speechSynthesis ? a.iOS ? (a.iOS9 ? a.systemVoicesReady(a.cache_ios9_voices) : a.systemVoicesReady(a.cache_ios_voices), console.log("RV: Voice support ready (cached)")) : (console.log("RV: speechSynthesis present but no system voices found"),
                        a.enableFallbackMode()) : a.enableFallbackMode()))
                }, 100)
            }, 100);
            a.Dispatch("OnLoad")
        },
        a.systemVoicesReady = function (b) {
            a.systemvoices = b;
            a.mapRVs();
            null != a.OnVoiceReady && a.OnVoiceReady.call();
            a.Dispatch("OnReady");
            window.hasOwnProperty("dispatchEvent") && window.dispatchEvent(new Event("ResponsiveVoice_OnReady"))
        },
        a.enableFallbackMode = function () {
            a.fallbackMode = !0;
            console.log("RV: Enabling fallback mode");
            a.mapRVs();
            null != a.OnVoiceReady && a.OnVoiceReady.call();
            a.Dispatch("OnReady");
            window.hasOwnProperty("dispatchEvent") &&
                window.dispatchEvent(new Event("ResponsiveVoice_OnReady"))
        },
        a.getVoices = function () {
            for (var b = [], c = 0; c < a.responsivevoices.length; c++) b.push({
                name: a.responsivevoices[c].name
            });
            return b
        },
        a.speak = function (b, c, f) {
            if (a.iOS9 && !a.iOS9_initialized) console.log("Initializing ios9"), setTimeout(function () {
                a.speak(b, c, f)
            }, 100), a.clickEvent(), a.iOS9_initialized = !0;
            else {
                a.isPlaying() && (console.log("Cancelling previous speech"), a.cancel());
                a.fallbackMode && 0 < a.fallback_audiopool.length && a.clearFallbackPool();
                b = b.replace(/[\"\`]/gm,
                    "'");
                a.msgparameters = f || {};
                a.msgtext = b;
                a.msgvoicename = c;
                a.onstartFired = !1;
                var h = [];
                if (b.length > a.CHARACTER_LIMIT) {
                    for (var e = b; e.length > a.CHARACTER_LIMIT;) {
                        var g = e.search(/[:!?.;]+/),
                            d = "";
                        if (-1 == g || g >= a.CHARACTER_LIMIT) g = e.search(/[,]+/); - 1 == g && -1 == e.search(" ") && (g = 99);
                        if (-1 == g || g >= a.CHARACTER_LIMIT)
                            for (var k = e.split(" "), g = 0; g < k.length && !(d.length + k[g].length + 1 > a.CHARACTER_LIMIT); g++) d += (0 != g ? " " : "") + k[g];
                        else d = e.substr(0, g + 1);
                        e = e.substr(d.length, e.length - d.length);
                        h.push(d)
                    }
                    0 < e.length && h.push(e)
                } else h.push(b);
                a.multipartText = h;
                g = null == c ? a.default_rv : a.getResponsiveVoice(c);
                !0 === g.deprecated && console.warn("ResponsiveVoice: Voice " + g.name + " is deprecated and will be removed in future releases");
                e = {};
                if (null != g.mappedProfile) e = g.mappedProfile;
                else if (e.systemvoice = a.getMatchedVoice(g), e.collectionvoice = {}, null == e.systemvoice) {
                    console.log("RV: ERROR: No voice found for: " + c);
                    return
                }
                1 == e.collectionvoice.fallbackvoice ? (a.fallbackMode = !0, a.fallback_parts = []) : a.fallbackMode = !1;
                a.msgprofile = e;
                a.utterances = [];
                for (g =
                    0; g < h.length; g++)
                    if (a.fallbackMode) {
                        a.fallback_playbackrate = a.def_fallback_playbackrate;
                        var d = a.selectBest([e.collectionvoice.pitch, e.systemvoice.pitch, 1]),
                            k = a.selectBest([a.iOS9 ? 1 : null, e.collectionvoice.rate, e.systemvoice.rate, 1]),
                            l = a.selectBest([e.collectionvoice.volume, e.systemvoice.volume, 1]),
                            m;
                        null != f && (d *= null != f.pitch ? f.pitch : 1, k *= null != f.rate ? f.rate : 1, l *= null != f.volume ? f.volume : 1, m = f.extraParams || null);
                        d /= 2;
                        k /= 2;
                        l *= 2;
                        d = Math.min(Math.max(d, 0), 1);
                        k = Math.min(Math.max(k, 0), 1);
                        l = Math.min(Math.max(l,
                            0), 1);
                        d = a.fallbackServicePath + "?t=" + encodeURIComponent(h[g]) + "&tl=" + (e.collectionvoice.lang || e.systemvoice.lang || "en-US") + "&sv=" + (e.collectionvoice.service || e.systemvoice.service || "") + "&vn=" + (e.collectionvoice.voicename || e.systemvoice.voicename || "") + "&pitch=" + d.toString() + "&rate=" + k.toString() + "&vol=" + l.toString();
                        m && (d += "&extraParams=" + JSON.stringify(m));
                        k = document.createElement("AUDIO");
                        k.src = d;
                        k.playbackRate = a.fallback_playbackrate;
                        k.preload = "auto";
                        k.load();
                        a.fallback_parts.push(k)
                    } else d = new SpeechSynthesisUtterance,
                        d.voice = e.systemvoice, d.voiceURI = e.systemvoice.voiceURI, d.volume = a.selectBest([e.collectionvoice.volume, e.systemvoice.volume, 1]), d.rate = a.selectBest([a.iOS9 ? 1 : null, e.collectionvoice.rate, e.systemvoice.rate, 1]), d.pitch = a.selectBest([e.collectionvoice.pitch, e.systemvoice.pitch, 1]), d.text = h[g], d.lang = a.selectBest([e.collectionvoice.lang, e.systemvoice.lang]), d.rvIndex = g, d.rvTotal = h.length, 0 == g && (d.onstart = a.speech_onstart), a.msgparameters.onendcalled = !1, null != f ? (g < h.length - 1 && 1 < h.length ? (d.onend = a.onPartEnd,
                                d.hasOwnProperty("addEventListener") && d.addEventListener("end", a.onPartEnd)) : (d.onend = a.speech_onend, d.hasOwnProperty("addEventListener") && d.addEventListener("end", a.speech_onend)), d.onerror = f.onerror || function (a) {
                                console.log("RV: Unknow Error");
                                console.log(a)
                            }, d.onpause = f.onpause, d.onresume = f.onresume, d.onmark = f.onmark, d.onboundary = f.onboundary || a.onboundary, d.pitch = null != f.pitch ? f.pitch : d.pitch, d.rate = a.iOS ? (null != f.rate ? f.rate * f.rate : 1) * d.rate : (null != f.rate ? f.rate : 1) * d.rate, d.volume = null != f.volume ?
                            f.volume : d.volume) : (d.onend = a.speech_onend, d.onerror = function (a) {
                            console.log("RV: Unknow Error");
                            console.log(a)
                        }), a.utterances.push(d), 0 == g && (a.currentMsg = d), console.log(d), a.tts_speak(d);
                a.fallbackMode && (a.fallback_part_index = 0, a.fallback_startPart())
            }
        },
        a.startTimeout = function (b, c) {
            var f = a.msgprofile.collectionvoice.timerSpeed;
            null == a.msgprofile.collectionvoice.timerSpeed && (f = 1);
            if (!(0 >= f)) {
                var h = b.split(/\s+/).length,
                    e = (b.match(/[^ ]/igm) || b).length,
                    f = 60 / a.WORDS_PER_MINUTE * f * 1E3 * (e / h / 5.1) * h;
                3 > h &&
                    (f = 4E3);
                3E3 > f && (f = 3E3);
                a.timeoutId = setTimeout(c, f)
            }
        },
        a.checkAndCancelTimeout = function () {
            null != a.timeoutId && (clearTimeout(a.timeoutId), a.timeoutId = null)
        },
        a.speech_timedout = function () {
            a.cancel();
            a.cancelled = !1;
            a.speech_onend()
        },
        a.speech_onend = function () {
            a.checkAndCancelTimeout();
            !0 === a.cancelled ? a.cancelled = !1 : null != a.msgparameters && null != a.msgparameters.onend && 1 != a.msgparameters.onendcalled && (a.msgparameters.onendcalled = !0, a.msgparameters.onend())
        },
        a.speech_onstart = function () {
            if (!a.onstartFired) {
                a.onstartFired = !0;
                if (a.iOS || a.is_safari || a.useTimer) a.fallbackMode || a.startTimeout(a.msgtext, a.speech_timedout);
                a.msgparameters.onendcalled = !1;
                if (null != a.msgparameters && null != a.msgparameters.onstart) a.msgparameters.onstart()
            }
        },
        a.fallback_startPart = function () {
            0 == a.fallback_part_index && a.speech_onstart();
            a.fallback_audio = a.fallback_parts[a.fallback_part_index];
            if (null == a.fallback_audio) console.log("RV: Fallback Audio is not available");
            else {
                var b = a.fallback_audio;
                a.fallback_audiopool.push(b);
                setTimeout(function () {
                    b.playbackRate =
                        a.fallback_playbackrate
                }, 50);
                b.onloadedmetadata = function () {
                    b.play();
                    b.playbackRate = a.fallback_playbackrate
                };
                a.fallback_errors && (console.log("RV: Speech cancelled due to errors"), a.speech_onend());
                a.fallback_audio.play();
                a.fallback_audio.addEventListener("ended", a.fallback_finishPart);
                a.useTimer && a.startTimeout(a.multipartText[a.fallback_part_index], a.fallback_finishPart)
            }
        },
        a.fallback_finishPart = function (b) {
            a.checkAndCancelTimeout();
            a.fallback_part_index < a.fallback_parts.length - 1 ? (a.fallback_part_index++,
                a.fallback_startPart()) : a.speech_onend()
        },
        a.cancel = function () {
            a.checkAndCancelTimeout();
            a.fallbackMode ? (null != a.fallback_audio && a.fallback_audio.pause(), a.clearFallbackPool()) : (a.cancelled = !0, speechSynthesis.cancel())
        },
        a.voiceSupport = function () {
            return "speechSynthesis" in window
        },
        a.OnFinishedPlaying = function (b) {
            if (null != a.msgparameters && null != a.msgparameters.onend) a.msgparameters.onend()
        },
        a.setDefaultVoice = function (b) {
            b = a.getResponsiveVoice(b);
            null != b && (a.default_rv = b)
        },
        a.mapRVs = function () {
            for (var b =
                    0; b < a.responsivevoices.length; b++)
                for (var c = a.responsivevoices[b], f = 0; f < c.voiceIDs.length; f++) {
                    var h = a.voicecollection[c.voiceIDs[f]];
                    if (1 != h.fallbackvoice) {
                        var e = a.getSystemVoice(h.name);
                        if (null != e) {
                            c.mappedProfile = {
                                systemvoice: e,
                                collectionvoice: h
                            };
                            break
                        }
                    } else {
                        c.mappedProfile = {
                            systemvoice: {},
                            collectionvoice: h
                        };
                        break
                    }
                }
        },
        a.getMatchedVoice = function (b) {
            for (var c = 0; c < b.voiceIDs.length; c++) {
                var f = a.getSystemVoice(a.voicecollection[b.voiceIDs[c]].name);
                if (null != f) return f
            }
            return null
        },
        a.getSystemVoice =
            function (b) {
                if ("undefined" === typeof a.systemvoices || null === a.systemvoices) return null;
                for (var c = 0; c < a.systemvoices.length; c++)
                    if (0 == a.systemvoices[c].name.localeCompare(b)) return a.systemvoices[c];
                return null
            },
        a.getResponsiveVoice = function (b) {
            for (var c = 0; c < a.responsivevoices.length; c++)
                if (a.responsivevoices[c].name == b) return a.responsivevoices[c];
            return null
        },
        a.Dispatch = function (b) {
            if (a.hasOwnProperty(b + "_callbacks") && null != a[b + "_callbacks"] && 0 < a[b + "_callbacks"].length) {
                for (var c = a[b + "_callbacks"],
                        f = 0; f < c.length; f++) c[f]();
                return !0
            }
            var h = b + "_callbacks_timeout",
                e = b + "_callbacks_timeoutCount";
            a.hasOwnProperty(h) || (a[e] = 10, a[h] = setInterval(function () {
                --a[e];
                (a.Dispatch(b) || 0 > a[e]) && clearTimeout(a[h])
            }, 50));
            return !1
        },
        a.AddEventListener = function (b, c) {
            a.hasOwnProperty(b + "_callbacks") || (a[b + "_callbacks"] = []);
            a[b + "_callbacks"].push(c)
        },
        a.addEventListener = a.AddEventListener,
        a.clickEvent = function () {
            if (a.iOS && !a.iOS_initialized) {
                console.log("Initializing iOS click event");
                var b = new SpeechSynthesisUtterance(" ");
                speechSynthesis.speak(b);
                a.iOS_initialized = !0
            }
        },
        a.isPlaying = function () {
            return a.fallbackMode ? null != a.fallback_audio && !a.fallback_audio.ended && !a.fallback_audio.paused : speechSynthesis.speaking
        },
        a.clearFallbackPool = function () {
            for (var b = 0; b < a.fallback_audiopool.length; b++) null != a.fallback_audiopool[b] && (a.fallback_audiopool[b].pause(), a.fallback_audiopool[b].src = "");
            a.fallback_audiopool = []
        },
        "complete" === document.readyState ? a.init() : document.addEventListener("DOMContentLoaded", function () {
            a.init()
        }),
        a.selectBest =
            function (a) {
                for (var c = 0; c < a.length; c++)
                    if (null != a[c]) return a[c];
                return null
            },
        a.pause = function () {
            a.fallbackMode ? null != a.fallback_audio && a.fallback_audio.pause() : speechSynthesis.pause()
        },
        a.resume = function () {
            a.fallbackMode ? null != a.fallback_audio && a.fallback_audio.play() : speechSynthesis.resume()
        },
        a.tts_speak = function (b) {
            setTimeout(function () {
                a.cancelled = !1;
                speechSynthesis.speak(b)
            }, .01)
        },
        a.setVolume = function (b) {
            if (a.isPlaying())
                if (a.fallbackMode) {
                    for (var c = 0; c < a.fallback_parts.length; c++) a.fallback_parts[c].volume =
                        b;
                    for (c = 0; c < a.fallback_audiopool.length; c++) a.fallback_audiopool[c].volume = b;
                    a.fallback_audio.volume = b
                } else
                    for (c = 0; c < a.utterances.length; c++) a.utterances[c].volume = b
        },
        a.onPartEnd = function (b) {
            if (null != a.msgparameters && null != a.msgparameters.onchuckend) a.msgparameters.onchuckend();
            a.Dispatch("OnPartEnd");
            b = a.utterances.indexOf(b.utterance);
            a.currentMsg = a.utterances[b + 1]
        },
        a.onboundary = function (b) {
            console.log("On Boundary");
            a.iOS && !a.onstartFired && a.speech_onstart()
        },
    }
    responsiveVoice = new ResponsiveVoice;